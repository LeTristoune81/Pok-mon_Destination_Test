<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Attaques par région</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body{margin:0;background:#0f1421;color:#dbe7ff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:1080px;margin:24px auto;padding:0 16px}
    h1{margin:0 0 12px}
    .note{opacity:.7;font-size:.95rem;margin-bottom:14px}
    .toolbar{display:flex;gap:8px;align-items:center;margin:12px 0 16px;flex-wrap:wrap}
    .toolbar input,.toolbar select{background:#0b1020;border:1px solid #27324a;border-radius:6px;color:#dbe7ff;padding:8px 10px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px}
    .card{background:#0b1020;border:1px solid #27324a;border-radius:10px;padding:12px}
    .card strong{color:#ffffff}
    .tag{display:inline-block;background:#1a2440;border:1px solid #334569;border-radius:999px;padding:2px 8px;margin-left:6px;font-size:.8rem}
    .small{opacity:.8;font-size:.9rem;margin-top:6px;line-height:1.2rem;white-space:pre-line}
    .alert{background:#24121a;border:1px solid #6d2a3c;color:#ffd6de;border-radius:8px;padding:10px 12px}
    a{color:#7db3ff;text-decoration:none}
    code{background:#101a2a;border:1px solid #27324a;border-radius:6px;padding:0 6px}
    .count{margin-left:10px; opacity:.85; font-size:.92rem; color:#bcd7ff}
    @media (max-width:520px){ .grid{grid-template-columns:repeat(auto-fill,minmax(200px,1fr))} }
  </style>
</head>
<body>
  <nav class="topnav" style="padding:8px 16px">
    <a href="/index.html">Accueil</a>
  </nav>

  <div class="wrap">
    <h1 id="title">Attaques de <span id="regionLabel">Johto</span></h1>
    <div class="note">(filtres CT / DT / CS / CU pour la région sélectionnée)</div>

    <div class="toolbar">
      <input id="search" type="search" placeholder="Rechercher une attaque…" />
      <label>Tag :
        <select id="tagSel">
          <option value="ALL" selected>Tous</option>
          <option value="CT">CT</option>
          <option value="DT">DT</option>
          <option value="CS">CS</option>
          <option value="CU">CU</option>
        </select>
      </label>
      <span id="count" class="count">0 attaques</span>
    </div>

    <div id="msg"></div>
    <div id="attacks" class="grid"></div>
  </div>

<script>
(async () => {
  // Région courante (?r=Johto)
  const url = new URL(location.href);
  const rParam = url.searchParams.get('r') || 'Johto';
  document.getElementById('regionLabel').textContent = rParam;

  // Chemins JSON (ajuste si tu utilises moves_index_clean.json)
  const PATH_MOVES   = '../../data/moves_index.json';
  const PATH_REGIONS = '../../data/regions_moves.json';

  const msg     = document.getElementById('msg');
  const grid    = document.getElementById('attacks');
  const search  = document.getElementById('search');
  const tagSel  = document.getElementById('tagSel');
  const countEl = document.getElementById('count');

  const norm = s => (s ?? '').toString().normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();

  async function loadJSON(path, label) {
    const res = await fetch(path);
    if (!res.ok) throw new Error(`${label} introuvable (${res.status}) : ${res.url}`);
    return res.json();
  }

  let movesAll, regions;
  try {
    movesAll = await loadJSON(PATH_MOVES, 'moves_index.json');
    regions  = await loadJSON(PATH_REGIONS, 'regions_moves.json');
  } catch (e) {
    msg.innerHTML = `<div class="alert">
      Erreur de chargement : ${e.message}<br>
      Vérifie que les fichiers existent bien aux emplacements :
      <div><code>${PATH_MOVES}</code></div>
      <div><code>${PATH_REGIONS}</code></div>
      Et que tu ouvres la page via un serveur local (ex : <code>http://127.0.0.1:5500/Pages/Attaques/region.html?r=Johto</code>).
    </div>`;
    return;
  }

  // Index des attaques
  const movesArray = Array.isArray(movesAll) ? movesAll : Object.values(movesAll || {});
  const idxByName  = new Map(movesArray.map(m => [m.name, m]));
  const idxByToken = new Map(movesArray.map(m => [m.token ?? m.upper ?? m.name, m]));

  // Région normalisée
  const keyWanted = norm(rParam);
  const foundKey  = Object.keys(regions).find(k => norm(k) === keyWanted);
  const regionData = (foundKey && regions[foundKey]) || { CT: [], DT: [], CS: [], CU: [] };

  // === Gestion descriptions multi-régions =======================================================
  const REGION_ALIASES = {
    "KANTO": ["KANTO"],
    "JOHTO": ["JOHTO","JOTHO"],
    "HOENN": ["HOENN"],
    "SINNOH": ["SINNOH","SINNO"],
    "UNYS": ["UNYS","UNOVA"],
    "KALOS": ["KALOS"],
    "ALOLA": ["ALOLA"],
    "GALAR": ["GALAR"],
    "PALDEA": ["PALDEA"]
  };

  function regionTagMatches(line, wanted) {
    const m = line.match(/^#\s*([A-ZÀÂÄÉÈÊËÎÏÔÖÙÛÜÇ\- ]+)\s*:/i);
    if (!m) return false;
    const tag = m[1].normalize('NFD').replace(/[\u0300-\u036f]/g,'').toUpperCase().replace(/\s+/g,'');
    const want = (wanted||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'').toUpperCase().replace(/\s+/g,'');
    const aliases = Object.entries(REGION_ALIASES).find(([k]) => k === want)?.[1] || [want];
    return aliases.includes(tag);
  }

  function matchesDescForRegion(desc, regionName) {
    if (!desc) return false;
    const lines = desc.replace(/\r\n/g, '\n').split('\n');
    return lines.some(l => /^#\s*[A-ZÀÂÄÉÈÊËÎÏÔÖÙÛÜÇ\- ]+\s*:/.test(l) && regionTagMatches(l, regionName));
  }

  function filterDescByRegion(desc, regionName) {
    if (!desc) return "";
    const lines = desc.replace(/\r\n/g, '\n').split('\n');
    const kept = [];
    for (const ln of lines) {
      if (/^#\s*[A-ZÀÂÄÉÈÊËÎÏÔÖÙÛÜÇ\- ]+\s*:/.test(ln)) {
        if (regionTagMatches(ln, regionName)) {
          kept.push(ln.replace(/^#\s*[A-ZÀÂÄÉÈÊËÎÏÔÖÙÛÜÇ\- ]+\s*:\s*/i, '').trim());
        }
      } else {
        kept.push(ln);
      }
    }
    return kept.join('\n').replace(/\n{3,}/g, '\n\n').trim();
  }

  // Fix moji-bake au cas où l'index a été mal encodé
  function fixMojibake(s){
    if (!s || !/[ÃÂ]/.test(s)) return s;
    try{
      const bytes = Uint8Array.from([...s].map(ch => ch.charCodeAt(0) & 0xFF));
      return new TextDecoder('utf-8').decode(bytes);
    }catch(_){ return s; }
  }

  // Normalisation d'une entrée région -> objet rendu
  const normalizeRegionMove = (raw) => {
    if (typeof raw === 'string') {
      const fromIdx = idxByName.get(raw) || idxByToken.get(raw);
      return fromIdx ? {
        name: fromIdx.name,
        type: fromIdx.type ?? '',
        category: fromIdx.category ?? '',
        power: fromIdx.power ?? null,
        accuracy: fromIdx.accuracy ?? null,
        pp: fromIdx.pp ?? null,
        description: filterDescByRegion(fixMojibake(fromIdx.description) ?? '', foundKey || rParam),
        source: 'index'
      } : { name: raw, type: '', category: '', power: null, accuracy: null, pp: null, description: '', source: 'name-only' };
    }

    const fromIdx = idxByName.get(raw.name) || idxByToken.get(raw.upper ?? raw.code);
    const descRegion = (raw.description && raw.description.trim()) ? raw.description : "";
    const descIndex  = fixMojibake(fromIdx?.description ?? "");
    const descMerged = descRegion || descIndex || "";
    const description = filterDescByRegion(descMerged, foundKey || rParam);

    return {
      name: (fromIdx?.name) ?? raw.name,
      type: (fromIdx?.type) ?? raw.type ?? '',
      category: (fromIdx?.category) ?? raw.categorie ?? '',
      power: (fromIdx?.power ?? fromIdx?.puissance) ?? raw.puissance ?? null,
      accuracy: (fromIdx?.accuracy ?? fromIdx?.precision) ?? raw.precision ?? null,
      pp: (fromIdx?.pp) ?? raw.pp ?? null,
      description,
      source: fromIdx ? 'merged' : 'region'
    };
  };

  // Liste filtrée par tag, avec extension CS cross-régions
  function listForTag(tagRaw) {
    const raw  = (tagRaw ?? '').toString().trim();
    const normTag = raw.replace(/\u2014/g, '').replace(/\u2013/g, '').replace(/-/g, '').replace(/\s+/g, '').toUpperCase();
    const valid = new Set(['CT','DT','CS','CU']);

    // 1) Base : contenu strict de la région courante
    const basePick = valid.has(normTag)
      ? (regionData[normTag] || [])
      : ['CT','DT','CS','CU'].flatMap(k => regionData[k] || []);

    // 2) Extension spéciale CS : ajouter les CS d'autres régions dont la description mentionne la région courante
    let pick = basePick;
    if (normTag === 'CS') {
      const extra = [];
      for (const [regName, buckets] of Object.entries(regions)) {
        const csList = buckets?.CS || [];
        for (const entry of csList) {
          const obj = (typeof entry === 'string') ? { name: entry, description: '' } : entry;
          const desc = obj?.description || '';
          if (matchesDescForRegion(desc, foundKey || rParam)) {
            extra.push(entry);
          }
        }
      }
      pick = pick.concat(extra);
    }

    // 3) Normaliser et dédupliquer par nom
    const normalized = pick.map(normalizeRegionMove);
    const seen = new Set();
    return normalized.filter(m => {
      const key = m.name;
      if (!key || seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  function updateCount(n) {
    countEl.textContent = ` ${n} ${n>1?'attaques':'attaque'}`;
  }

  function render() {
    const tag = tagSel.value;
    const q   = norm(search.value);
    const list = listForTag(tag)
      .filter(m => !q || norm(m.name).includes(q) || norm(m.description).includes(q));

    updateCount(list.length);
    if (!list.length) {
      grid.innerHTML = `<div class="alert">Aucune attaque trouvée pour ce filtre.</div>`;
      return;
    }
    grid.innerHTML = list.map(m => `
      <div class="card">
        <div><strong>${m.name}</strong>${m.type ? `<span class="tag">${m.type}</span>` : ''}</div>
        ${m.category ? `<div>Catégorie : ${m.category}</div>` : ''}
        <div>Puissance : ${m.power ?? '-'}&nbsp;&nbsp;Précision : ${m.accuracy ?? '-'}&nbsp;&nbsp;PP : ${m.pp ?? '-'}</div>
        ${m.description ? `<div class="small">${m.description}</div>` : ''}
      </div>
    `).join('');
  }

  search.addEventListener('input', render);
  tagSel.addEventListener('change', render);
  render();
})();
</script>

</body>
</html>
